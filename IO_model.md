# I/O

- **I/O 是什么**

  输入/输出流

- **I/O 的分类（以写入为例）**

  - **缓存 I/O（标准 I/O，大多数系统的默认 I/O 方式）**
      1.  将数据拷贝至 application 缓冲区；
      2.  将数据拷贝至 kernel 缓冲区；
      3.  写入磁盘。

  - **直接 I/O**
    1.  直接将数据拷贝至 kernel 缓冲区；
    2.  写入磁盘。

  直接 I/O 相比缓存 I/O 少了**将数据拷贝至 application 缓冲区**这一步

- **I/O model（以读取为例）**

  -   **Block I/O model** 

      1.  进程发起 read，进行 recvfrom 系统调用，期间进程阻塞；
      2.  kernel 开始准备数据，并将准备好的数据拷贝到进程缓冲区，期间进程阻塞；
      3.  进程收到数据，解阻塞。

      Block I/O 的特点是，在**内核准备数据**和**数据从内核缓冲区拷贝到进程缓冲区**这两个过程都是阻塞的。

  -   **Non-block I/O model**

      1.  进程发起 read，进行 recvfrom 系统调用，等待数据准备完毕的信号；
      2.  当数据未准备完毕时，系统返回 error 并立即解阻塞，开启下一轮轮询，直到数据准备完毕；
      3.  当数据准备完毕时，kernel 将准备好的数据拷贝到进程缓冲区，期间进程阻塞；
      4.  进程收到数据，解阻塞。

      Non-block I/O 的特点是，用户进程会不断轮询，调用 recvfrom，直到数据准备好为止，只在**数据从内核缓冲区拷贝到进程缓冲区**这个过程中阻塞。

  -   **Multiplexing I/O model**

      1.  进程进行 select 系统调用，整个进程阻塞；
      2.  kernel 会监视所有 select 负责的 socket；
      3.  一旦其中有一个 socket 准备好数据，select 就返回；
      4.  这时再调用 recvfrom 接收数据（此时一般使用 Non-block I/O）。

      Multiplexing I/O 的第一个特点是，支持监视多个 socket，只要有一个 socket 返回，select 就可以返回；第二个特点是，进程不会阻塞于 recvfrom，而只阻塞于 select；第三个特点是，当连接数不高时，性能较低，甚至不如多线程+Block I/O，用 select 的优势在于能处理多个连接，而不是让单个连接处理得更快。

  -   **Signal Drive I/O model**

      1.  定义一个信号函数，当内核准备好数据时，向进程发送 SIGIO 信号；
      2.  系统调用信号函数，然后直接返回，不阻塞进程；
      3.  直到进程收到 SIGIO 信号，然后调用 recvfrom 接收数据。

      Signal Drive I/O 的特点是，建立一个与内核直接通信的函数，当函数返回信号时，进程才开始调用 recvfrom，仍然属于同步 I/O。

  -   **Asynchronous I/O model**

      1.  进程发起 aio_read 时给 kernel 传输一些自身的信息参数，然后立刻解阻塞去做其它操作，从 kernel 的角度来说，kernel 收到这个异步 read 后，它会立即返回，不会阻塞进程；
      2.  然后 kernel 开始准备数据，期间跟进程无关联，即进程不阻塞；
      3.  kernel 将数据复制到进程缓冲区，然后通知进程操作已完成。

      Asynchronous I/O 的特点是，在文件 I/O 时仍然不会阻塞，所有事情都交由内核处理，处理完毕后让内核通知即可。

- **阻塞与非阻塞的区别**

阻塞和非阻塞关注的是**进程在等待调用结果（消息、返回值）时的状态**。阻塞是指调用结果返回之前，当前进程会被挂起。调用进程只有在得到结果才会返回。非阻塞调用指不能立刻得到结果，该调用不会阻塞当前进程。

- **同步与异步的区别**

同步与异步关注的是**进程之间的协作方式**，同步是A进程必须得到B进程通知才能去执行某件事（A执行），异步是指A进程通知B进程去执行然后立刻得到返回，然后就可以去做自己的事，B完成之后会给A发一个通知（B执行）。
